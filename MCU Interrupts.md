- signal generated by event external to the CPU
- causes to stop CPU currently doing and jump to a separate piece of code 
- ISR (Interrupt Service Routine)
	- code that handles the interrupt request then execute
	- when finish returns to the instruction running prior the interrupt
	- must be as short as possible. to allow other interrupts 
		- as we have to turn off all interrupts GIE 
- accomodate 1 interrupt at a time
- [[GIE (Global Interrupt Enable)]]
- Disadvantage of interrupts
	- interrupt can be confusing and error prone
	- overlapping of events ay happen together with the main routine
	- not further delay the foreground routine
- Before CPU runs its ISR it uses [[Program Counter (PC)]]
	- stores program counter value to a stack
- you can enable and disable interrupts
- [[Interrupt Masking]]
	- interrupt disabling 
Common Interrupt Sources
- Input pin state change
- Timer Overflow 
- External Interrupts RB0

How do we input the code
- in assembly it uses address
- in C:
```c
	void interrupt ISR()
	{
	//acts like a function
	GIE = 0;
	if(INTF)
	{
		INTF=0;
		
	}
	}
	main()
	{
	}
```

OPTION_REG
- INTEDG
	- identifies if the interrupt is occuring 
INTCON
- GIE
	- BIT7
- INTE (the masker)
	- bit 4 RB0/INT External Interrupt Enable bit
- INTF
	- External interrupt Flag bit
		- identifies if the interrupt occurs
		- need manual reset 
### Questions:
What happens if there are multiple interrupts being triggered
- is there a hierarchy which one runs first


```c
int main (){
	unsigned char counter = 0x00;
	while(1)
	{
		if (myIntF = 0)
		{
			while (myIntF != 1)
			{
			}
		
		}
		else if (counter == 0x09)//why this nine?
		{
		counter = 0x00
		}
		else 
		{
			counter++;
		}
		PORTC = counter;
	}
}
```